/*
Reads a MIDI object created by Tonejs/Midi and converts it to an Overwatch workshop array.
*/


"use strict";

// Range of notes on the overwatch piano, 
// based on the MIDI scale (0 - 127).
// One integer is one semitone.
const PIANO_RANGE = Object.freeze({
    MIN: 24,
    MAX: 88
});
const OCTAVE = 12;

const SETTINGS_INFO = Object.freeze({
    startTime:		{MIN:0, MAX:Infinity,   DEFAULT:0},
    stopTime:		{MIN:0, MAX:Infinity,   DEFAULT:100},
    maxVoices:		{MIN:1, MAX:11,         DEFAULT:6},
    maxElements:	{MIN:12, MAX:999,       DEFAULT:600}
});

const defaultSettings = {
    startTime:		SETTINGS_INFO["startTime"]["DEFAULT"],
    stopTime:		SETTINGS_INFO["stopTime"]["DEFAULT"],
    maxVoices:		SETTINGS_INFO["maxVoices"]["DEFAULT"],
    maxElements:	SETTINGS_INFO["maxElements"]["DEFAULT"]
};


function transposePitch(pitch) {
    while (pitch < PIANO_RANGE.MIN) {
        pitch += OCTAVE;
    }
    while (pitch > PIANO_RANGE.MAX) {
        pitch -= OCTAVE;
    }
    return pitch;
}


function roundToPlaces(value, decimalPlaces) {
    // Todo: validate decimalPlaces maybe?
    return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
}


function readMidiData(mid, settings) {
    // Reads the contents of a Midi object (generated by Tonejs/Midi)
    // to a map with times (float) of chords as keys 
    // and pitches (array of ints) in those chords as values

    let chords = new Map();

    let skippedNotes = 0;
    let transposedNotes = 0;

    for (let track of mid.tracks) {
        if (track.channel == 9) {
            // Percussion channel, ignore track
            continue;
        }
        
        for (let note of track.notes) {
            if (note.velocity == 0) {
                // Note off event, not used by the Overwatch piano
                continue;
            }
            if (note.time < settings["startTime"] || note.time > settings["stopTime"]) {
                continue;
            }

            let pitch = note.midi;
            if (pitch < PIANO_RANGE.MIN || pitch > PIANO_RANGE.MAX) {
                transposedNotes += 1
                pitch = transposePitch(pitch);
            }

            pitch -= PIANO_RANGE.MIN;
            let chordTime = roundToPlaces(note.time, 3);

            if (chords.has(chordTime)) {
                if (!chords.get(chordTime).includes(pitch)) {

                    if (chords.get(chordTime).length < settings["maxVoices"]) {
                        chords.get(chordTime).push(pitch);
                    } else {
                        skippedNotes += 1;
                    }
                }
            } else {
                chords.set( chordTime, [pitch] );
            }
        }
    }

    let output = "";

    if (chords.size == 0) {
        output += `Error: no notes found in MIDI file between ` +
                  `${settings["startTime"]} seconds ` +
                  `and ${settings["stopTime"]} seconds.`;
    } else {
        output += `${skippedNotes} note(s) left out ` +
                  `due to too many overlapping pitches\n` +
                  `${transposedNotes} note(s) transposed\n`;

        // Sort by keys (times)
        chords = new Map([...chords.entries()].sort( (time1, time2) => 
                                                    { return roundToPlaces(parseFloat(time1) 
                                                      - parseFloat(time2), 3) } ));
    }

    return { chords, output };
}


function convertToArray(chords, settings, output) {
    // Converts the contents of the chords map 
    // to a format compatible with Overwatch

    // Sort chords.values() by length and get the length of the 0th element 
    // to get the amount of voices in the largest chord
    let maxPitches = Array.from(chords.values()
                            ).sort( (a, b) => { return b.length - a.length; }
                            )[0].length;
    
    output += `${maxPitches} voice(s)\n\n`;

    let owArrays = [ [maxPitches] ];

    // Time of first note
    let prevTime = chords.keys().next().value;
    let currentArray = 0;
    for (let [time, pitches] of chords.entries()) {

        if (1 + pitches.length + owArrays[currentArray].length > settings["maxElements"]) {
            owArrays.push( [] );
            currentArray += 1;
        }

        // One chord in the song consists of 
        // A) "Vector(timeSinceLastChord, amountOfPitchesInChord, 0)"
        owArrays[currentArray].push(`Vector(${roundToPlaces(time - prevTime, 3)},` +
                                   `${pitches.length},0)`);
        // and B) the pitches in that chord
        for (let pitch of pitches.sort()) {
            owArrays[currentArray].push(pitch);
        }
        
        prevTime = time;
    }

    let totalElements = owArrays.reduce( (a, b) => { return a + b.length; }, 0 );

    output += `MIDI file successfully read from ${settings["startTime"]} second(s) ` +
              `to ${roundToPlaces(settings["stopTime"], 3)} second(s).\n` +
              `${owArrays.length} Overwatch array(s) created ` +
              `with a total of ${totalElements} elements.\n`;
    
    return { owArrays, output };
}


function writeWorkshopRules(owArrays) {
    // Writes workshop rules containing the song data in arrays, 
    // ready to be pasted into Overwatch
    
    let rules = [];

    let arrayNumber = 0;
    for (let dataArray of owArrays) {

        let actions = `Set Global Variable(tempArray, Empty Array);`;

        for (let newElement of dataArray) {
            actions += `Modify Global Variable(tempArray, ` + 
                       `Append To Array, ${newElement});`;
        }
        actions += `Set Global Variable At Index(songData, ${arrayNumber},` + 
                   `Global Variable(tempArray));`

        let newRule = `rule(\"Song Data\"){event{Ongoing-Global;}` +
                      `actions{${actions}}}`;
        rules.push(newRule);
        
        arrayNumber += 1;
    }

    return rules.join("");
}

function convertMidi(mid, settings={}) {
    /*
    param mid:  a Midi object created by Tonejs/Midi
    param settings: a JS object containing user parameters for 
                    parsing the midi data, see defaultSettings for an example

    Return: a JS object { rules, scriptOutput }, containing:
        string rules:    Overwatch workshop rules containing the song Data,
                         or an empty string if an error occurred
        string scriptOutput:    information output by the script, 
                                including error messages
    */

    if (Object.keys(settings).length == 0) {
        settings = defaultSettings;
    }

    let chordInfo = readMidiData(mid, settings);
    let rules = "";
    let scriptOutput = chordInfo.output;

    if (chordInfo.chords.size != 0) {
        let arrayInfo = convertToArray(chordInfo.chords, settings, chordInfo.output);

        scriptOutput = arrayInfo.output;
        rules = writeWorkshopRules(arrayInfo.owArrays);
    }
    
    return { rules, scriptOutput };
}
