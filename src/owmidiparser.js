/*
Reads a MIDI object created by Tonejs/Midi and converts it to an Overwatch workshop array.
*/


"use strict";

// Range of notes on the overwatch piano, 
// based on the MIDI scale (0 - 127).
// One integer is one semitone.
const PIANO_RANGE = Object.freeze({
    MIN: 24,
    MAX: 88
});
const OCTAVE = 12;

const CONVERTER_SETTINGS_INFO = Object.freeze({
    startTime:		{MIN:0, MAX:Infinity,   DEFAULT:0},
    stopTime:		{MIN:0, MAX:Infinity,   DEFAULT:100},
    maxPitches:		{MIN:1, MAX:11,         DEFAULT:6},
    maxElements:	{MIN:12, MAX:999,       DEFAULT:600}
});

const DEFAULT_SETTINGS = {
    startTime:		CONVERTER_SETTINGS_INFO["startTime"]["DEFAULT"],
    stopTime:		CONVERTER_SETTINGS_INFO["stopTime"]["DEFAULT"],
    maxPitches:		CONVERTER_SETTINGS_INFO["maxPitches"]["DEFAULT"],
    maxElements:	CONVERTER_SETTINGS_INFO["maxElements"]["DEFAULT"]
};

const CONVERTER_WARNINGS = {
    TYPE_0_FILE: "WARNING: The processed file is a type 0 file and may have been converted incorrectly.\n"
};

const CONVERTER_ERRORS = {
    NO_NOTES_FOUND: `Error: no notes found in MIDI file in the given range.\n`
};


function convertMidi(mid, settings={}) {
    /*
    param mid:  a Midi object created by Tonejs/Midi
    param settings: a JS object containing user parameters for 
                    parsing the midi data, see DEFAULT_SETTINGS for an example

    Return: a JS object, containing:
        string rules:           Overwatch workshop rules containing the song Data,
                                or an empty string if an error occurred
        int transposedNotes:    Amount of notes transposed to the range of the Overwatch piano
        int skippedNotes:       Amount of notes skipped due to too many pitches in a chord
        int maxPitches:         Amount of pitches in the largest chord
        int totalElements:      Total amount of elements in the song data arrays of the workshop script
        int totalArrays:        Total amount of song data arrays in the workshop script 
        array warnings:         An array of strings containing warnings by the script
        array errors:           An array of strings containing errors by the script
    */

    if (Object.keys(settings).length != Object.keys(CONVERTER_SETTINGS_INFO).length) {
        settings = DEFAULT_SETTINGS;
    }

    let chordInfo = readMidiData(mid, settings);
    let rules = "";

    let arrayInfo = {};
    if (chordInfo.chords.size != 0) {
        arrayInfo = convertToArray(chordInfo.chords, settings, chordInfo.maxPitches);

        rules = writeWorkshopRules(arrayInfo.owArrays);
    }
    
    return { 
        rules:              rules, 
        skippedNotes:       chordInfo.skippedNotes, 
        transposedNotes:    chordInfo.transposedNotes,
        maxPitches:         chordInfo.maxPitches,
        totalElements:      arrayInfo.totalElements,
        totalArrays:        arrayInfo.totalArrays,
        warnings:           chordInfo.warnings,
        errors:             chordInfo.errors
    };
}


function readMidiData(mid, settings) {
    // Reads the contents of a Midi object (generated by Tonejs/Midi)
    // to a map with times (float) of chords as keys 
    // and pitches (array of ints) in those chords as values

    let chords = new Map();

    let skippedNotes = 0;
    let transposedNotes = 0;

    for (let track of mid.tracks) {
        if (track.channel == 9) {
            // Percussion channel, ignore track
            continue;
        }
        
        for (let note of track.notes) {
            if (note.velocity == 0) {
                // Note off event, not used by the Overwatch piano
                continue;
            }
            if (note.time < settings["startTime"] || note.time > settings["stopTime"]) {
                continue;
            }

            let notePitch = note.midi;
            if (notePitch < PIANO_RANGE["MIN"] || notePitch > PIANO_RANGE["MAX"]) {
                transposedNotes += 1
                notePitch = transposePitch(notePitch);
            }

            notePitch -= PIANO_RANGE["MIN"];
            let noteTime = roundToPlaces(note.time, 3);

            if (chords.has(noteTime)) {
                if (!chords.get(noteTime).includes(notePitch)) {

                    if (chords.get(noteTime).length < settings["maxPitches"]) {
                        chords.get(noteTime).push(notePitch);
                    } else {
                        skippedNotes += 1;
                    }
                }
            } else {
                chords.set( noteTime, [notePitch] );
            }
        }
    }

    let maxPitches = 0;
    let warnings = []
    let errors = [];

    if (chords.size == 0) {
        errors.push(CONVERTER_ERRORS["NO_NOTES_FOUND"]);
    } else {
        // Sort chords.values() by length and get the length of the 0th element 
        // to get the amount of pitches in the largest chord
        maxPitches = Array.from(chords.values()
                            ).sort( (a, b) => { return b.length - a.length; }
                            )[0].length;
            
        // Sort by keys (times)
        chords = new Map([...chords.entries()].sort( (time1, time2) => 
                                                    { return roundToPlaces(parseFloat(time1) 
                                                      - parseFloat(time2), 3) } ));
    }

    if (mid.tracks.length == 1) {
        // Type 0 midi files have only one track
        warnings.push(CONVERTER_WARNINGS["TYPE_0_FILE"]);
    }

    return { 
        chords, 
        skippedNotes, 
        transposedNotes, 
        maxPitches, 
        warnings, 
        errors 
    };
}


function convertToArray(chords, settings, maxPitches) {
    // Converts the contents of the chords map 
    // to a format compatible with Overwatch

    let owArrays = [ [maxPitches] ];

    // Time of first note
    let prevTime = chords.keys().next().value;
    let currentArray = 0;
    for (let [chordTime, pitches] of chords.entries()) {

        // if currentArray is too long, create a new one
        if (1 + pitches.length + owArrays[currentArray].length > settings["maxElements"]) {
            owArrays.push( [] );
            currentArray += 1;
        }

        // One chord in the song consists of 
        // A) "Vector(timeSinceLastChord, amountOfPitchesInChord, 0)"
        owArrays[currentArray].push(`Vector(${roundToPlaces(chordTime - prevTime, 3)},` +
                                   `${pitches.length},0)`);
        // and B) the pitches in that chord
        for (let pitch of pitches.sort()) {
            owArrays[currentArray].push(pitch);
        }
        
        prevTime = chordTime;
    }

    let totalArrays = owArrays.length;
    let totalElements = owArrays.reduce( (a, b) => { return a + b.length; }, 0 );
    
    return { owArrays, totalElements, totalArrays };
}


function writeWorkshopRules(owArrays) {
    // Writes workshop rules containing the song data in arrays, 
    // ready to be pasted into Overwatch
    
    let rules = [];

    let arrayNumber = 0;
    for (let dataArray of owArrays) {

        let actions = `Set Global Variable(tempArray, Empty Array);`;

        for (let newElement of dataArray) {
            actions += `Modify Global Variable(tempArray, ` + 
                       `Append To Array, ${newElement});`;
        }
        actions += `Set Global Variable At Index(songData, ${arrayNumber},` + 
                   `Global Variable(tempArray));`

        let newRule = `rule(\"Song Data\"){event{Ongoing-Global;}` +
                      `actions{${actions}}}`;
        rules.push(newRule);
        
        arrayNumber += 1;
    }

    return rules.join("");
}


function transposePitch(pitch) {
    while (pitch < PIANO_RANGE["MIN"]) {
        pitch += OCTAVE;
    }
    while (pitch > PIANO_RANGE["MAX"]) {
        pitch -= OCTAVE;
    }
    return pitch;
}

function roundToPlaces(value, decimalPlaces) {
    // Todo: validate decimalPlaces?
    return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
}
